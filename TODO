TODO

* Implement auto-convert to Q-space / Angstroms on data load

* Implement multiprocessing for speedier calculations

* Redundant code > multiple definitions of warning message dialog boxes?

* Implement option to use Hadju tabulations?

* core.data_manip.zero_norm is dead code > remove?

* Change mouse position label precision depending on plot zoom level

* convert_two_theta in core.data_manip is ambiguously named


# Example Hadju compton scattering calculation
# > Tabulation (in Hadju) doesn't exist for some elements
---------------------------------------------------
def hadju(element, atomic_ff, Q):
    # Test run just for 'Ca' 'Al' and 'O' - CaAl2O4
    Ca_data = [20, 0.5207, 0.9320, 18.112]
    O_data = [8, 0.3933, 1.2843, 32.6820]
    Al_data = [13, 0.5268, 1.2263, 13.932]
    key_data = ['Z', 'M', 'K', 'L']
    if element == 'Ca':
        hadju_data = dict(zip(key_data, Ca_data))
    elif element == 'O':
        hadju_data = dict(zip(key_data, O_data))
    elif element == 'Al':
        hadju_data = dict(zip(key_data, Al_data))
    else:
        raise ValueError
       

    element = hadju_data['Z'], 0, 1
   
    aff_part = hadju_data['Z'] - ((atomic_ff**2) / hadju_data['Z'])
    s = Q/(np.pi*4)
    cs_part = 1 - hadju_data['M'] * (np.exp(hadju_data['K'] * s * -1) - np.exp(hadju_data['L'] * s * -1))
    compton_scattering = aff_part * cs_part
   
    return compton_scattering

def calc_tot_hadju(composition, Q):
    compton_scattering = []
    for element in composition:
        aff = calc_atomic_ff(composition[element], Q)
        compton_scattering.append(hadju(element, aff, Q) * composition[element][2])
    compton_scattering = np.sum(np.asarray(compton_scattering),0)
    return compton_scattering
